# primitive types
str, int, depth, id, ptr

# todo for align, size, min/max, depth fixed value may I use int as a primitive type ?
# todo for skip and unreachable instructions, is it okay if I don't have parens for the constructor?
# todo for type: NamedType, how does that fit in ? do we need type constructors ? May these be inferred ?

alive = Opt(boolPred? precondition, prog src, prog tgt)

prog = Prog(instr* instructions)

boolPred = BinaryBoolPred(binBoolPredOp op, operand v1, operand v2)
    | LLVMBoolPred(llvmBoolPredOp, operand* args) # like with const fun you can parse this out more broadly
    | PredOr(boolPred* args)
    | PredAnd(boolPred* args)
    | PredNot(boolPred v)
    | TruePred

precOperand = const | input

instr = cmpInstr | stdInstr

cmpInstr = Icmp(id reg, icmpOp op, type t, value v1, value v2)

    # assign instructions
stdInstr = CopyOperand(id reg, value v, type t)
    | BinOp(id reg, binOp op, type t, value v1, value v2, flag* flags)
    | ConversionOp(id reg, conversionOp op, type st, value v, type t)
    # this will be Icmp here in select as c; it would be nice
    # to force the c in select to only be of Icmp constructor
    | Select(id reg, type t, instr c, value v1, value v2) # if conditionalExpr == 1, then v1, else v1
    # The ‘alloca‘ instruction allocates memory on the stack frame of the currently executing function, to be automatically released when this function returns to its caller. The object is always allocated in the address space for allocas indicated in the datalayout.
    # align: this is an integer which defines alignment in memory; default is 0
    | Alloca(id reg, type t, type elemsType, value numElems, int align) ## allocates mem on stack
    | GEP(id reg, type t, ptr p, idx* i, inbounds) # get element pointer ## todo
    | Load(id reg, type st, value v, int align)

    # instructions w/out assign
    | Store(type st, value src, type t, value dst, int align) # todo align
    | Br(str bb_label , value cond , str true, str false) # todo more on this; we actually don't need to support these
    | Ret(str bb_label, type t, value val) # todo more on this
    | Skip
    | Unreachable

const = ConstantVal(int val, type t) #todo type for v ? for all const!
    | UndefVal(type t)
    | CnstUnaryOp(cnstUnaryOp op, value v)
    | CnstBinaryOp(cnstBinOp, const c1, const c2)
    | CnstFunction(cnstFunOp, value* args, type t)
    # todo decide: we could also expand out CnstFunction out and add constraints on the number of args for binary
    # todo cont... and unary const function
        # update: I like this idea a lot: it may take extra refactoring work


type = UnknownType(int? depth) # todo Depth? ? default = 0
    | NamedType(str name)
    | IntType(int size)
    | PtrType(type? t, int? d) # default depth = 0
    | ArrayType(value? e, type? t, int? d)


input = Input(id name, type t) # must start with % or
# what is the true point of TypeFixedValue?
typeFixedValue = TypeFixedValue(id name, value v, int min, int max)

value = input | typeFixedValue

# TypeFixedValue(id name, value v, int min, int max) # todo uncertain what min and max really function as
#    | Input(id name, type t) # must start with % or


cnstUnaryOp = Not | Neg

cnstFunOp = abs | sbits | obits | zbits | ctlz | cttz | log2 | lshr | max | sext | trunc | umax
    | width | zext


# it seems wise to keep these exactly the same as strings for simplicity
flags = nsw | nuw | exact

icmpOp = EQ | NE | UGT | UGE | ULT | ULE | SGT | SGE | SLT | SLE | Var | Last

conversionOp = Trunc | ZExt | SExt | ZExtOrTrunc | Ptr2Int | Int2Ptr | Bitcast | Last

binOp = Add | Sub | Mul | UDiv | SDiv | URem | SRem | Shl | AShr | LShr | And | Or | Xor | Last

cnstBinOp = And | Or | Xor | Add | Sub | Mul | Div | DivU | Rem | RemU | AShr | LShr | Shl
